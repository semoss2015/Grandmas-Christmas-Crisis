<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grandma's Rescue: Winter Rush</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --warmth-color: #f59e0b; /* Amber */
            --danger-color: #ef4444; /* Red */
            --safe-color: #10b981; /* Emerald */
            --primary-text: #f3f4f6; /* Gray 100 */
            --bg-dark: #1f2937; /* Gray 800 */
            --bg-medium: #374151; /* Gray 700 */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-dark);
            color: var(--primary-text);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        .game-container {
            width: 100%;
            max-width: 900px;
            background-color: var(--bg-medium);
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            padding: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #gameCanvas {
            border: 2px solid #4b5563;
            background-color: #ffffff; /* Snow background */
            touch-action: none; /* Disable default touch actions */
        }
        .button-primary {
            background-color: var(--safe-color);
            color: var(--bg-dark);
            padding: 12px 30px;
            border-radius: 0.5rem;
            font-weight: 700;
            font-size: 1.25rem;
            transition: all 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        .button-primary:hover {
            background-color: #059669; /* Emerald 600 */
            transform: translateY(-2px);
        }
        .hud {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            margin-bottom: 10px;
        }
        .warmth-bar-container {
            width: 150px;
            height: 20px;
            background-color: #4b5563;
            border-radius: 9999px;
            overflow: hidden;
            border: 1px solid #1f2937;
        }
        #warmth-bar {
            height: 100%;
            background-color: var(--warmth-color);
            transition: width 0.3s, background-color 0.3s;
        }
        .leaderboard-list li {
            padding: 4px 0;
            border-bottom: 1px dashed #4b5563;
        }
        .leaderboard-list li:last-child {
            border-bottom: none;
        }
        /* Mobile Joystick Styles */
        #joystick-area {
            position: relative;
            width: 150px;
            height: 150px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            margin-top: 20px;
            background-color: rgba(0, 0, 0, 0.1);
        }
        #joystick-area:before {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
        }
        #joystick-head {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            transition: background-color 0.1s;
        }

        /* Responsive Layout */
        @media (max-width: 768px) {
            .hud {
                flex-direction: column;
                gap: 10px;
            }
            .hud > div {
                width: 100%;
                text-align: center;
            }
            #joystick-area {
                display: block; /* Show joystick on small screens */
            }
        }
        @media (min-width: 769px) {
            #joystick-area {
                display: none; /* Hide joystick on large screens */
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-4xl font-extrabold mb-4 text-warmth-color">Grandma's Rescue: Winter Rush</h1>

        <div class="hud text-lg font-semibold">
            <div>Level: <span id="hud-level" class="text-safe-color">1</span></div>
            <div>Score: <span id="hud-score" class="text-safe-color">0</span></div>
            <div class="flex items-center space-x-2">
                <span>Warmth:</span>
                <div class="warmth-bar-container">
                    <div id="warmth-bar" style="width: 100%;"></div>
                </div>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <!-- Joystick Area for Mobile/Touch -->
        <div id="joystick-area" class="touch-only">
            <div id="joystick-head"></div>
        </div>

        <!-- Start/Game Over Overlay -->
        <div id="game-overlay" class="absolute inset-0 bg-black bg-opacity-75 flex flex-col items-center p-8 z-10 transition-opacity duration-500 hidden overflow-auto">
            <div id="start-screen" class="max-w-md w-full text-center">
                <h2 class="text-4xl font-extrabold text-warmth-color mb-6">Start Your Rush!</h2>
                <div id="instructions" class="bg-gray-800 p-6 rounded-lg text-left mb-6 max-h-96 overflow-y-auto">
                    <h3 class="text-2xl font-bold mb-3 border-b pb-1">Goal:</h3>
                    <p class="mb-4 text-gray-300">Find the <span class="text-yellow-400 font-bold">Purse</span> and return it to <span class="text-green-400 font-bold">Grandma</span>!</p>
                    
                    <h3 class="text-2xl font-bold mb-3 border-b pb-1">Controls:</h3>
                    <p class="mb-4 text-gray-300">Use **WASD / Arrow Keys** or the **On-Screen Joystick (Touch)** to move.</p>

                    <h3 class="text-2xl font-bold mb-3 border-b pb-1">Hazards & Collectibles:</h3>
                    <ul class="list-disc list-inside space-y-2 text-gray-300">
                        <li class="flex items-center"><canvas id="icon-player" width="20" height="20" class="mr-2"></canvas> You: <span class="text-warmth-color font-semibold">Warmth</span> decays constantly. If it hits 0, you freeze!</li>
                        <li class="flex items-center"><canvas id="icon-cocoa" width="20" height="20" class="mr-2"></canvas> Cocoa: Collect to restore <span class="text-safe-color">+25 Warmth</span>.</li>
                        <li class="flex items-center"><canvas id="icon-grinch" width="20" height="20" class="mr-2"></canvas> Grinch: Avoid the Grinch! Collision means Game Over.</li>
                        <li class="flex items-center"><canvas id="icon-purse" width="20" height="20" class="mr-2"></canvas> Purse: The item you need to find.</li>
                        <li class="flex items-center"><canvas id="icon-grandma" width="20" height="20" class="mr-2"></canvas> Grandma: Your final destination.</li>
                    </ul>
                </div>
                <button id="start-game-button" class="button-primary">Start Game</button>
            </div>

            <div id="game-over-screen" class="max-w-md w-full text-center hidden">
                <h2 class="text-5xl font-extrabold mb-4 text-danger-color">GAME OVER</h2>
                <p class="text-2xl mb-2">Level Reached: <span id="go-level" class="text-safe-color font-bold">0</span></p>
                <p class="text-3xl mb-4">Final Score: <span id="go-score" class="text-warmth-color font-bold">0</span></p>
                
                <p class="text-sm text-gray-400 mb-4">Auth ID: <span id="go-user-id" class="font-mono text-xs">Loading... (Not used for scoring)</span></p>

                <div id="submission-area" class="bg-gray-800 p-6 rounded-lg mb-6">
                    <p class="mb-3 text-lg font-semibold">New High Score?</p>
                    <input type="text" id="player-name-input" placeholder="Enter Your Name (Max 15 Chars)" 
                           maxlength="15"
                           class="w-full p-3 mb-4 bg-gray-700 border border-gray-600 rounded-md text-white focus:ring-warmth-color focus:border-warmth-color">
                    
                    <button id="submit-score-button" class="button-primary w-full" disabled>
                        Submit Score
                    </button>
                    <p id="submission-message" class="text-sm mt-2 text-green-400 hidden">Score Submitted!</p>
                </div>
                
                <div class="bg-gray-800 p-6 rounded-lg mb-6">
                    <h3 class="text-3xl font-bold mb-4 border-b pb-2 text-warmth-color">Global Top 3</h3>
                    <ul id="leaderboard-list" class="leaderboard-list space-y-2 text-xl">
                        <li class="text-gray-400">Loading scores...</li>
                    </ul>
                </div>

                <button id="restart-game-button" class="button-primary">Play Again</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDK Imports (MUST be type="module") -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, getDoc, onSnapshot, serverTimestamp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GLOBAL FIREBASE/ENVIRONMENT VARIABLES ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // --- FIREBASE STATE ---
        let app, db, auth;
        let currentUserId = null;
        let isAuthReady = false;

        // --- GAME CONSTANTS ---
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 500;
        const PLAYER_SPEED_BASE = 3;
        const PLAYER_SIZE = 20;
        const GRINCH_SIZE = 20;
        const ITEM_SIZE = 15;
        const WARMTH_DECAY_BASE = 0.5; // Warmth per second at Level 1
        const GRINCH_SPEED_BASE = 1.5;

        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const hudLevel = document.getElementById('hud-level');
        const hudScore = document.getElementById('hud-score');
        const warmthBar = document.getElementById('warmth-bar');
        const overlay = document.getElementById('game-overlay');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const goLevel = document.getElementById('go-level');
        const goScore = document.getElementById('go-score');
        const goUserId = document.getElementById('go-user-id');
        const playerNameInput = document.getElementById('player-name-input');
        const submitScoreButton = document.getElementById('submit-score-button');
        const submissionMessage = document.getElementById('submission-message');
        const leaderboardList = document.getElementById('leaderboard-list');

        // --- GAME STATE ---
        let gameState = 'START';
        let lastTime = 0;
        let score = 0;
        let level = 1;
        let player = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2, dx: 0, dy: 0, warmth: 100, hasPurse: false };
        let grandma = { x: 50, y: 50, size: 30 };
        let purse = {};
        let cocoa = [];
        let grinches = [];
        let trees = [];

        // --- INPUT STATE (Keyboard and Joystick) ---
        const keys = {};
        let joystick = { active: false, x: 0, y: 0, dx: 0, dy: 0, radius: 75 };
        const joystickArea = document.getElementById('joystick-area');
        const joystickHead = document.getElementById('joystick-head');

        // Set up canvas dimensions
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;


        // --- FIREBASE AND LEADERBOARD FUNCTIONS ---

        setLogLevel('debug');

        /**
         * Gets the Firestore collection reference for the public leaderboard.
         * Public path: /artifacts/{appId}/public/data/leaderboard
         */
        function getLeaderboardRef() {
            return collection(db, `artifacts/${appId}/public/data/leaderboard`);
        }

        /**
         * Initializes Firebase and authenticates the user.
         */
        async function initializeFirebase() {
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        goUserId.textContent = currentUserId;
                        isAuthReady = true;
                        setupLeaderboardListener();
                        // Enable submission button if user is authenticated
                        submitScoreButton.disabled = false;
                        submitScoreButton.textContent = "Submit High Score";
                    } else {
                        // Sign in anonymously if no token is available or user is signed out
                        await signInAnonymously(auth);
                    }
                });

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    // Start anonymous sign-in flow
                    await signInAnonymously(auth);
                }

            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                goUserId.textContent = 'Auth Error.';
            }
        }

        /**
         * Sets up the real-time listener for the public leaderboard.
         */
        function setupLeaderboardListener() {
            if (!isAuthReady) return; 

            const leaderboardRef = getLeaderboardRef();
            
            // Listen for changes to the leaderboard collection
            onSnapshot(leaderboardRef, (snapshot) => {
                let scores = [];
                snapshot.forEach(doc => {
                    scores.push(doc.data());
                });

                // Sort by score descending, then by timestamp ascending (for ties)
                scores.sort((a, b) => {
                    if (a.score !== b.score) {
                        return b.score - a.score;
                    }
                    // Handle timestamp: if timestamp is null (still saving), push it down
                    const timeA = a.timestamp ? a.timestamp.toMillis() : Infinity;
                    const timeB = b.timestamp ? b.timestamp.toMillis() : Infinity;
                    return timeA - timeB; 
                });

                // Display only the top 3 scores as per prompt
                renderLeaderboard(scores.slice(0, 3));

            }, (error) => {
                console.error("Error fetching leaderboard:", error);
                leaderboardList.innerHTML = '<li class="text-danger-color">Could not load leaderboard.</li>';
            });
        }

        /**
         * Renders the leaderboard list in the UI.
         */
        function renderLeaderboard(scores) {
            leaderboardList.innerHTML = ''; 

            if (scores.length === 0) {
                leaderboardList.innerHTML = '<li class="text-gray-400">No scores posted yet.</li>';
                return;
            }

            scores.forEach((item, index) => {
                const li = document.createElement('li');
                li.className = 'flex justify-between items-center text-lg font-semibold';
                
                const nameColor = index === 0 ? 'text-yellow-400' : 'text-white';

                li.innerHTML = `
                    <div class="flex items-center space-x-3">
                        <span class="text-xl w-6 text-right">${index + 1}.</span>
                        <span class="${nameColor} font-extrabold">${item.name}</span>
                    </div>
                    <span class="text-warmth-color text-2xl font-bold">${item.score}</span>
                `;
                leaderboardList.appendChild(li);
            });
        }

        /**
         * Submits the final score to Firestore. The document ID is now the player's name (sanitized).
         */
        async function submitScore() {
            // Sanitize the player name and use it as the unique key
            const playerName = playerNameInput.value.trim().substring(0, 15);
            const sanitizedName = playerName.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase(); // Use a safe key for Firestore
            
            if (!isAuthReady || !sanitizedName || playerName.length < 2) {
                // Use a visual modal message instead of alert
                submissionMessage.textContent = "Error: Name required (2+ chars) or auth failed.";
                submissionMessage.classList.remove('text-green-400');
                submissionMessage.classList.add('text-danger-color');
                submissionMessage.classList.remove('hidden');
                return;
            }

            submitScoreButton.disabled = true;
            submitScoreButton.textContent = "Saving...";
            submissionMessage.classList.add('hidden');

            try {
                // Doc ID is now the sanitized Player Name
                const docRef = doc(getLeaderboardRef(), sanitizedName);
                const docSnap = await getDoc(docRef);

                let isNewHighScore = true;
                if (docSnap.exists()) {
                    const existingScore = docSnap.data().score || 0;
                    if (score <= existingScore) {
                        isNewHighScore = false;
                    }
                }

                if (isNewHighScore) {
                    const scoreData = {
                        // Save the display name, but use the sanitized name for the Document ID
                        name: playerName, 
                        score: score,
                        timestamp: serverTimestamp(),
                        userId: currentUserId, // Keep this for reference/security but not as the primary key
                        levelReached: level,
                    };

                    await setDoc(docRef, scoreData);
                    
                    submissionMessage.textContent = `New High Score Saved for ${playerName}!`;
                    submissionMessage.classList.remove('hidden');
                    submissionMessage.classList.remove('text-danger-color');
                    submissionMessage.classList.add('text-green-400');
                    
                } else {
                    submissionMessage.textContent = `Score (${score}) is not a new high score for ${playerName}.`;
                    submissionMessage.classList.remove('hidden');
                    submissionMessage.classList.remove('text-green-400');
                    submissionMessage.classList.add('text-danger-color');
                }
                
            } catch (e) {
                console.error("Error submitting score:", e);
                submissionMessage.textContent = "Submission Failed. See console.";
                submissionMessage.classList.remove('hidden');
                submissionMessage.classList.remove('text-green-400');
                submissionMessage.classList.add('text-danger-color');
            } finally {
                submitScoreButton.disabled = false;
                submitScoreButton.textContent = "Submit High Score";
            }
        }


        // --- GAME LOGIC FUNCTIONS ---

        /**
         * Resets the game state for a new level or start.
         */
        function resetGame(newLevel = 1) {
            level = newLevel;
            score = 0;
            player.warmth = 100;
            player.hasPurse = false;
            player.x = CANVAS_WIDTH / 2;
            player.y = CANVAS_HEIGHT / 2;
            player.dx = 0;
            player.dy = 0;
            
            // Clear entities
            cocoa = [];
            grinches = [];
            trees = [];
            
            initializeLevel(level);
        }

        /**
         * Initializes entities based on the current level.
         */
        function initializeLevel(lvl) {
            // Level complexity adjustments
            const numGrinches = lvl;
            const numCocoa = 5 + lvl * 2;
            const numTrees = 20 + lvl * 5;
            
            // 1. Set Grandma position (static)
            grandma.x = 50;
            grandma.y = 50;

            // 2. Set Purse position (opposite corner, hidden)
            purse.x = CANVAS_WIDTH - 50;
            purse.y = CANVAS_HEIGHT - 50;
            purse.found = false;

            // 3. Grinches
            for (let i = 0; i < numGrinches; i++) {
                grinches.push(createRandomEntity(GRINCH_SIZE, GRINCH_SPEED_BASE + lvl * 0.5));
            }

            // 4. Cocoa
            for (let i = 0; i < numCocoa; i++) {
                cocoa.push(createRandomEntity(ITEM_SIZE, 0));
            }

            // 5. Trees (static obstacles)
            for (let i = 0; i < numTrees; i++) {
                trees.push(createRandomEntity(10, 0));
            }
        }

        /**
         * Creates an entity at a random, safe location.
         */
        function createRandomEntity(size, speed) {
            let x, y, safe = false;
            const padding = 50;
            const minDistanceToPlayer = 100;

            while (!safe) {
                x = Math.random() * (CANVAS_WIDTH - size * 2) + size;
                y = Math.random() * (CANVAS_HEIGHT - size * 2) + size;

                // Check distance from player start position
                const dist = Math.hypot(x - player.x, y - player.y);
                if (dist > minDistanceToPlayer) {
                    safe = true;
                }
            }
            
            return {
                x: x, y: y, size: size,
                speed: speed,
                dx: (Math.random() - 0.5) * speed,
                dy: (Math.random() - 0.5) * speed,
                collected: false
            };
        }

        /**
         * Handles the level completion logic.
         */
        function completeLevel() {
            score += level * 100;
            level++;
            // Move to the next level's state
            initializeLevel(level);
            player.hasPurse = false; // Reset purse status
            showLevelUpMessage();
        }

        /**
         * Draws the level up message temporarily.
         */
        function showLevelUpMessage() {
            // This is a temporary visual effect. The game state remains 'PLAYING'.
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.fillStyle = '#f59e0b';
            ctx.font = '60px Inter';
            ctx.textAlign = 'center';
            ctx.fillText(`Level ${level-1} Complete!`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 40);
            ctx.font = '30px Inter';
            ctx.fillText(`Starting Level ${level}...`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
            ctx.restore();
            
            // Resume drawing after 2 seconds
            setTimeout(() => {
                // The main game loop will naturally redraw the scene
            }, 2000);
        }

        /**
         * Main game loop, runs approximately 60 times per second.
         */
        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTime) / 1000; // seconds
            lastTime = timestamp;

            if (gameState === 'PLAYING') {
                update(deltaTime);
                draw();
            } else if (gameState === 'START') {
                drawStartScreen();
            } else if (gameState === 'GAME_OVER') {
                // Draw final frame and then wait
                draw(); 
            }

            requestAnimationFrame(gameLoop);
        }

        /**
         * Updates game logic based on delta time.
         */
        function update(deltaTime) {
            // --- 1. Warmth Decay ---
            const warmthDecayRate = WARMTH_DECAY_BASE * level;
            player.warmth -= warmthDecayRate * deltaTime;
            if (player.warmth < 0) {
                player.warmth = 0;
                setGameState('GAME_OVER');
                return;
            }
            player.warmth = Math.min(100, player.warmth); // Cap at 100

            // --- 2. Player Movement ---
            let moveX = keys['ArrowRight'] || keys['d'] || 0;
            let moveY = keys['ArrowDown'] || keys['s'] || 0;
            
            // Check for left/up/joystick input
            if (keys['ArrowLeft'] || keys['a']) moveX = -1;
            if (keys['ArrowUp'] || keys['w']) moveY = -1;

            if (joystick.active) {
                moveX = joystick.dx;
                moveY = joystick.dy;
            }
            
            // Normalize diagonal speed
            if (moveX !== 0 && moveY !== 0) {
                const magnitude = Math.hypot(moveX, moveY);
                moveX /= magnitude;
                moveY /= magnitude;
            }

            const playerSpeed = PLAYER_SPEED_BASE;
            player.dx = moveX * playerSpeed;
            player.dy = moveY * playerSpeed;

            player.x += player.dx;
            player.y += player.dy;

            // Keep player within bounds
            player.x = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_WIDTH - PLAYER_SIZE / 2, player.x));
            player.y = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_HEIGHT - PLAYER_SIZE / 2, player.y));

            // --- 3. Grinch Movement and Collision ---
            const grinchSpeed = GRINCH_SPEED_BASE + level * 0.5;

            grinches.forEach(g => {
                // Simple random patrol with edge bounce
                if (Math.random() < 0.01) { // 1% chance to change direction
                    g.dx = (Math.random() - 0.5) * grinchSpeed;
                    g.dy = (Math.random() - 0.5) * grinchSpeed;
                }
                
                g.x += g.dx;
                g.y += g.dy;

                // Bounce off walls
                if (g.x < GRINCH_SIZE/2 || g.x > CANVAS_WIDTH - GRINCH_SIZE/2) g.dx *= -1;
                if (g.y < GRINCH_SIZE/2 || g.y > CANVAS_HEIGHT - GRINCH_SIZE/2) g.dy *= -1;

                // Collision with Player (Ends Game)
                if (checkCollision(player, g)) {
                    setGameState('GAME_OVER');
                    return;
                }
            });

            // --- 4. Collectibles and Goal Check ---
            // Cocoa Collection
            cocoa = cocoa.filter(c => {
                if (checkCollision(player, c)) {
                    player.warmth += 25; // Restore Warmth
                    score += 10;
                    return false; // Remove collected cocoa
                }
                return true; // Keep uncollected cocoa
            });

            // Purse Collection
            if (!player.hasPurse && checkCollision(player, purse)) {
                player.hasPurse = true;
                purse.found = true;
                score += 50;
            }

            // Goal Check (Grandma)
            if (player.hasPurse && checkCollision(player, grandma)) {
                completeLevel();
            }

            // --- 5. Update HUD ---
            updateHUD();
        }

        /**
         * Checks circular collision between two entities.
         */
        function checkCollision(e1, e2) {
            const size1 = e1.size || PLAYER_SIZE;
            const size2 = e2.size || ITEM_SIZE;
            const distance = Math.hypot(e1.x - e2.x, e1.y - e2.y);
            return distance < (size1 / 2) + (size2 / 2);
        }

        /**
         * Draws all game elements.
         */
        function draw() {
            // Clear canvas (Snow ground)
            ctx.fillStyle = '#f0f4f8';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Draw Trees (Static obstacles)
            trees.forEach(t => {
                drawTree(t.x, t.y, t.size);
            });

            // Draw Grandma (Goal)
            drawGrandma(grandma.x, grandma.y, grandma.size);

            // Draw Purse
            if (!player.hasPurse) {
                drawPurse(purse.x, purse.y, ITEM_SIZE);
            } else {
                // Draw purse attached to player (optional visual cue)
                // drawPurse(player.x - 10, player.y - 10, ITEM_SIZE * 0.7);
            }

            // Draw Cocoa (Warmth pickups)
            cocoa.forEach(c => {
                drawCocoa(c.x, c.y, ITEM_SIZE);
            });

            // Draw Grinches (Enemies)
            grinches.forEach(g => {
                drawGrinch(g.x, g.y, GRINCH_SIZE);
            });

            // Draw Player (Last to be on top)
            drawPlayer(player.x, player.y, PLAYER_SIZE, player.hasPurse);

            // Draw Level Up Message (if active) - this is handled by showLevelUpMessage() now
        }

        /**
         * Draws the game's start screen.
         */
        function drawStartScreen() {
            // The overlay handles the visual display, just ensure the canvas is cleared
            ctx.fillStyle = '#f0f4f8';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Draw instruction icons on the start screen UI
            drawIcon('icon-player', drawPlayer, { x: 10, y: 10, size: 20, hasPurse: false });
            drawIcon('icon-grandma', drawGrandma, { x: 10, y: 10, size: 20 });
            drawIcon('icon-purse', drawPurse, { x: 10, y: 10, size: 20 });
            drawIcon('icon-grinch', drawGrinch, { x: 10, y: 10, size: 20 });
            drawIcon('icon-cocoa', drawCocoa, { x: 10, y: 10, size: 20 });
        }
        
        /**
         * Helper to draw entity icons on the instruction canvas elements.
         */
        function drawIcon(id, drawer, params) {
            const iconCanvas = document.getElementById(id);
            if (iconCanvas) {
                const iconCtx = iconCanvas.getContext('2d');
                iconCtx.clearRect(0, 0, iconCanvas.width, iconCanvas.height);
                iconCtx.translate(iconCanvas.width / 2, iconCanvas.height / 2);
                drawer(params.x - params.size/2, params.y - params.size/2, params.size, params.hasPurse);
                iconCtx.setTransform(1, 0, 0, 1, 0, 0); // Reset translation
            }
        }


        // --- DRAWING ENTITIES (Canvas Replicas) ---

        function drawPlayer(x, y, size, hasPurse) {
            ctx.save();
            ctx.translate(x, y);

            // Body (Blue/Orange)
            ctx.beginPath();
            ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
            ctx.fillStyle = hasPurse ? '#f59e0b' : '#3b82f6';
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#1e3a8a';
            ctx.stroke();

            // Eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-size * 0.15, -size * 0.1, size * 0.15, 0, Math.PI * 2);
            ctx.arc(size * 0.15, -size * 0.1, size * 0.15, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawGrandma(x, y, size) {
            ctx.save();
            ctx.translate(x, y);

            // Chair/Body (Green, Goal area)
            ctx.beginPath();
            ctx.rect(-size / 2, -size / 2, size, size);
            ctx.fillStyle = '#10b981';
            ctx.fill();
            ctx.strokeStyle = '#065f46';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Head (White)
            ctx.beginPath();
            ctx.arc(0, -size / 2, size / 3, 0, Math.PI * 2);
            ctx.fillStyle = '#fefefe';
            ctx.fill();

            ctx.restore();
        }

        function drawPurse(x, y, size) {
            ctx.save();
            ctx.translate(x, y);

            // Purse body (Gold)
            ctx.beginPath();
            ctx.rect(-size / 2, 0, size, size * 0.8);
            ctx.fillStyle = '#fbbf24';
            ctx.fill();
            ctx.strokeStyle = '#92400e';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Clasp
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.2, 0, Math.PI, true);
            ctx.lineTo(size * 0.5, 0);
            ctx.strokeStyle = '#92400e';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.restore();
        }

        function drawCocoa(x, y, size) {
            ctx.save();
            ctx.translate(x, y);

            // Mug (Red)
            ctx.beginPath();
            ctx.rect(-size / 2, 0, size, size * 0.8);
            ctx.fillStyle = '#ef4444';
            ctx.fill();
            ctx.strokeStyle = '#991b1b';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Cocoa steam (White dots)
            ctx.fillStyle = 'white';
            ctx.fillRect(-size * 0.1, -size * 0.2, size * 0.2, size * 0.05);
            ctx.fillRect(size * 0.2, -size * 0.1, size * 0.1, size * 0.05);

            ctx.restore();
        }

        function drawGrinch(x, y, size) {
            ctx.save();
            ctx.translate(x, y);

            // Body (Dark Green)
            ctx.beginPath();
            ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
            ctx.fillStyle = '#065f46';
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#047857';
            ctx.stroke();
            
            // Mean Eyes
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(-size * 0.15, -size * 0.1, size * 0.1, 0, Math.PI * 2);
            ctx.arc(size * 0.15, -size * 0.1, size * 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Frown
            ctx.beginPath();
            ctx.arc(0, size * 0.2, size * 0.2, 0, Math.PI, false);
            ctx.strokeStyle = '#92400e';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.restore();
        }

        function drawTree(x, y, size) {
            ctx.save();
            ctx.translate(x, y);

            // Trunk (Brown)
            ctx.fillStyle = '#b45309';
            ctx.fillRect(-size / 4, size / 2, size / 2, size / 2);

            // Leaves/Branches (Green Triangle)
            ctx.beginPath();
            ctx.moveTo(0, size / 2);
            ctx.lineTo(-size * 1.5, -size / 2);
            ctx.lineTo(size * 1.5, -size / 2);
            ctx.closePath();
            ctx.fillStyle = '#065f46';
            ctx.fill();
            ctx.strokeStyle = '#047857';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.restore();
        }

        // --- UI & STATE MANAGEMENT ---

        /**
         * Updates the Warmth bar and HUD text.
         */
        function updateHUD() {
            hudLevel.textContent = level;
            hudScore.textContent = score;

            const warmthPercent = player.warmth;
            warmthBar.style.width = warmthPercent + '%';

            // Change bar color based on warmth level
            if (warmthPercent > 60) {
                warmthBar.style.backgroundColor = 'var(--safe-color)';
            } else if (warmthPercent > 20) {
                warmthBar.style.backgroundColor = 'var(--warmth-color)';
            } else {
                warmthBar.style.backgroundColor = 'var(--danger-color)';
            }
        }

        /**
         * Changes the game state and handles transition effects.
         */
        function setGameState(newState) {
            gameState = newState;
            overlay.classList.remove('hidden');
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');

            if (newState === 'START') {
                resetGame(1);
                overlay.classList.remove('hidden');
                startScreen.classList.remove('hidden');
            } else if (newState === 'GAME_OVER') {
                goLevel.textContent = level;
                goScore.textContent = score;
                playerNameInput.value = ''; // Clear input
                submissionMessage.classList.add('hidden');
                submitScoreButton.disabled = !isAuthReady;
                
                // Show game over screen
                overlay.classList.remove('hidden');
                gameOverScreen.classList.remove('hidden');
                
                // Note: submitScore is NOT automatically called here anymore.
                // The user must type a name and click the button.
            } else if (newState === 'PLAYING') {
                overlay.classList.add('hidden');
            }
        }

        // --- INPUT HANDLERS ---

        document.addEventListener('keydown', (e) => {
            if (gameState === 'PLAYING') {
                keys[e.key.toLowerCase()] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (gameState === 'PLAYING') {
                keys[e.key.toLowerCase()] = false;
                
                // Reset player velocity if movement keys are released and joystick is inactive
                if (!joystick.active && (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key.match(/^[wasd]$/i))) {
                    player.dx = 0;
                    player.dy = 0;
                }
            }
        });

        // --- JOYSTICK HANDLERS (Touch/Mobile Input) ---

        function updateJoystick(x, y) {
            const rect = joystickArea.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            let deltaX = x - centerX;
            let deltaY = y - centerY;
            let distance = Math.hypot(deltaX, deltaY);

            // Clamp distance to joystick radius
            if (distance > joystick.radius) {
                const ratio = joystick.radius / distance;
                deltaX *= ratio;
                deltaY *= ratio;
                distance = joystick.radius;
            }

            // Move the visual joystick head
            joystickHead.style.left = `${deltaX + rect.width / 2 - 25}px`;
            joystickHead.style.top = `${deltaY + rect.height / 2 - 25}px`;

            // Calculate normalized direction for game logic (joystick.dx/dy)
            joystick.dx = deltaX / joystick.radius;
            joystick.dy = deltaY / joystick.radius;
        }

        function handleStart(e) {
            if (gameState !== 'PLAYING') return;
            e.preventDefault();
            const touch = e.changedTouches ? e.changedTouches[0] : e;
            
            const rect = joystickArea.getBoundingClientRect();
            
            // Check if the touch/click is within the joystick area
            if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
                touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
                
                joystick.active = true;
                joystickHead.style.backgroundColor = 'rgba(255, 255, 255, 0.7)';
                updateJoystick(touch.clientX, touch.clientY);
            }
        }

        function handleMove(e) {
            if (gameState !== 'PLAYING' || !joystick.active) return;
            e.preventDefault();
            const touch = e.changedTouches ? e.changedTouches[0] : e;
            updateJoystick(touch.clientX, touch.clientY);
        }

        function handleEnd(e) {
            if (!joystick.active) return;
            e.preventDefault();
            joystick.active = false;
            joystick.dx = 0;
            joystick.dy = 0;
            
            // Center the visual joystick head
            joystickHead.style.left = 'calc(50% - 25px)';
            joystickHead.style.top = 'calc(50% - 25px)';
            joystickHead.style.backgroundColor = 'rgba(255, 255, 255, 0.4)';
        }

        // Attach touch/mouse listeners for the joystick
        joystickArea.addEventListener('mousedown', handleStart);
        joystickArea.addEventListener('mousemove', handleMove);
        joystickArea.addEventListener('mouseup', handleEnd);
        joystickArea.addEventListener('mouseleave', handleEnd);

        joystickArea.addEventListener('touchstart', handleStart);
        joystickArea.addEventListener('touchmove', handleMove);
        joystickArea.addEventListener('touchend', handleEnd);
        joystickArea.addEventListener('touchcancel', handleEnd);


        // --- INITIALIZATION ---

        window.onload = function() {
            initializeFirebase(); // Setup Firebase Auth and Leaderboard listener

            // Event listeners for screen transitions
            document.getElementById('start-game-button').addEventListener('click', () => {
                resetGame(1);
                setGameState('PLAYING');
            });

            document.getElementById('restart-game-button').addEventListener('click', () => {
                setGameState('START');
            });

            submitScoreButton.addEventListener('click', submitScore);

            // Start the main loop
            requestAnimationFrame(gameLoop);
            
            // Initial draw for the start screen
            setGameState('START');
        };